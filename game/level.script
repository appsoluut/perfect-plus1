go.property("current_level", 1)
go.property("max_levels", 19)

local width, height = window.get_size()
local tile_size = 16
local zoom = 4

local defsave = require "defsave.defsave"
local lume = require "libraries.lume"
local monarch = require "monarch.monarch"

local acceleration = 4
local max_movement_speed = 16

local tile_empty = 0
local tile_wall = 2
local tile_floor = 3
local tile_exit = 4
local tile_player_start = 5
local tile_oneway_left = 6
local tile_oneway_right = 7
local tile_oneway_up = 8
local tile_oneway_down = 9
local tile_teleporter_green = 10
local tile_teleporter_purple = 11

local idle_animations = {
	[hash("idle")] = 4,
	[hash("idle_left")] = 4,
	[hash("idle_right")] = 4,
	[hash("idle_up")] = 4,
	[hash("idle_down")] = 4,
	[hash("blink")] = 2
}

local function animate_background()
	local size = go.get_scale("/scroll")

	local scale = vmath.vector4(size.x / tile_size, size.y / tile_size, 0, 0)
	go.set("/scroll#plane", "scale", scale)
	go.set("/scroll#plane", "tint.w", 0.66)
	go.animate("/scroll#plane", "animation_time.x", go.PLAYBACK_LOOP_FORWARD, scale.xy, go.EASING_LINEAR, 120 * scale.xy)
end

local function play_idle_animation(self)
	local animation_to_play = lume.weightedchoice(idle_animations)
	sprite.play_flipbook(self.player_sprite_url, animation_to_play, play_idle_animation)
end

local function spawn_special_tile(self, tile, x, y)
	local spawn = nil

	if tile == tile_teleporter_green then
		spawn = "teleporter_green"
		table.insert(self.teleporters.green, { x = x, y = y })
	elseif tile == tile_teleporter_purple then
		spawn = "teleporter_purple"
		table.insert(self.teleporters.purple, { x = x, y = y })
	end

	if spawn then
		local position = vmath.vector3(0, 0, 0.1)
		position.x = self.tilemap_position.x + (tile_size * x - tile_size / 2)
		position.y = self.tilemap_position.y + (tile_size * y - tile_size / 2)

		local id = factory.create(msg.url(nil, "special", spawn), position)
		table.insert(self.special_tiles, id)
	end
end

local function load_tilemap(self)
	local data = sys.load_resource("/game/levels/level" .. self.current_level .. ".lua")
	if data ~= nil then
		local level_data = assert(loadstring(data))()
		self.required_moves = level_data.properties.moves
		self.level_name = level_data.properties.name
		self.teleporters = { green = {}, purple = {} }
		msg.post(msg.url(nil, "gui", "level"), hash("update_required"), { required = self.required_moves })
		msg.post(msg.url(nil, "gui", "level"), hash("update_levelname"), { level_name = self.level_name })
		for _, layer in ipairs(level_data.layers) do
			for y = 1, layer.height do
				for x = 1, layer.width do
					tilemap.set_tile(self.tilemap_level_url, layer.name, x, layer.height + 1 - y, layer.data[(y - 1) * layer.width + x])
				end
			end
		end
		defsave.set("settings", "level", self.current_level)
	else
		print("[ERROR] Level not found?")
	end
end

local function init_tilemap_position(self)
	self.tilemap_position = go.get(self.tilemap_url, "position")

	self.tilemap_x, self.tilemap_y, self.tilemap_width, self.tilemap_height = tilemap.get_bounds(self.tilemap_level_url)

	self.tilemap_position.x = (width / 2) - (self.tilemap_width * tile_size) / 2
	self.tilemap_position.y = height / 2 - (self.tilemap_height * tile_size) / 2

	go.set(self.tilemap_url, "position", self.tilemap_position)
end

local function init_tilemap_data(self)
	self.tilemap_data = tilemap.get_tiles(self.tilemap_level_url, "walls")
	self.exit_tile_position = { x = 0, y = 0 }
	self.player_start_tile_position = { x = 0, y = 0 }
	self.tilemap_items = tilemap.get_tiles(self.tilemap_level_url, "items")
	for row = 1, #self.tilemap_items do
		for col = 1, #self.tilemap_items[row] do
			if self.tilemap_items[row][col] == tile_exit then
				self.exit_tile_position.x = col
				self.exit_tile_position.y = row
			elseif self.tilemap_items[row][col] == tile_player_start then
				self.player_start_tile_position.x = col
				self.player_start_tile_position.y = row
			elseif self.tilemap_items[row][col] == tile_teleporter_green
			or self.tilemap_items[row][col] == tile_teleporter_purple then
				spawn_special_tile(self, self.tilemap_items[row][col], col, row)
			end

			if self.tilemap_items[row][col] ~= tile_oneway_down
			and self.tilemap_items[row][col] ~= tile_oneway_left
			and self.tilemap_items[row][col] ~= tile_oneway_right
			and self.tilemap_items[row][col] ~= tile_oneway_up then
				tilemap.set_tile(self.tilemap_level_url, "items", col, row, tile_empty)
			end
		end
	end
end

local function init_player_position(self)
	self.player_position = go.get(self.player_url, "position")
	self.player_position.x = self.tilemap_position.x + (tile_size * self.player_start_tile_position.x - tile_size / 2)
	self.player_position.y = self.tilemap_position.y + (tile_size * self.player_start_tile_position.y - tile_size / 2)
	self.player_tile_position = {
		x = self.player_start_tile_position.x,
		y = self.player_start_tile_position.y
	}
	go.set(self.player_url, "position", self.player_position)
end

local function init_exit_position(self)
	self.exit_position = vmath.vector3(0, 0, 0.1)
	self.exit_position.x = self.tilemap_position.x + (tile_size * self.exit_tile_position.x - tile_size / 2)
	self.exit_position.y = self.tilemap_position.y + (tile_size * self.exit_tile_position.y - tile_size / 2)
	local id = factory.create(msg.url(nil, "special", "exit"), self.exit_position)
	table.insert(self.special_tiles, id)
end

local function load_level(self)
	self.speed = 0
	self.moves = 0
	self.required_moves = 0

	if self.special_tiles then
		go.delete(self.special_tiles)
		self.special_tiles = {}
	end
	self.special_tiles = {}

	msg.post(msg.url(nil, "gui", "level"), hash("update_moves"), { moves = self.moves })

	load_tilemap(self)
	init_tilemap_position(self)
	init_tilemap_data(self)
	init_player_position(self)
	init_exit_position(self)

	play_idle_animation(self)
end

local function reset_level(self)
	self.moves = 0
	self.movement = nil
	self.teleporting = nil
	msg.post(msg.url(nil, "gui", "level"), hash("update_moves"), { moves = self.moves })

	self.player_position.x = self.tilemap_position.x + (tile_size * self.player_start_tile_position.x - tile_size / 2)
	self.player_position.y = self.tilemap_position.y + (tile_size * self.player_start_tile_position.y - tile_size / 2)
	self.player_tile_position = {
		x = self.player_start_tile_position.x,
		y = self.player_start_tile_position.y
	}
	go.set(self.player_url, "position", self.player_position)

	play_idle_animation(self)
end

local function play_lost_animation(self)
	sound.play(msg.url(nil, "sound", "fail"))
	self.resetting = true
	sprite.play_flipbook(self.player_sprite_url, "lose", function(self)
		self.resetting = nil
		reset_level(self)
	end)
end

function init(self)
	msg.post("@render:", "use_fixed_projection", { near = -1, far = 1, zoom = zoom })

	local data = monarch.data("level")
	if data ~= nil and data.current_level then
		self.current_level = data.current_level
	end

	sound.play(msg.url(nil, "sound", "music"))

	self.tilemap_url = msg.url(nil, "level", nil)
	self.tilemap_level_url = msg.url(nil, "level", "tilemap")
	self.player_url = msg.url(nil, "player", nil)
	self.player_sprite_url = msg.url(nil, "player", "sprite")
	self.player_size = go.get(self.player_sprite_url, "size")

	animate_background()
	load_level(self)

	msg.post(".", "acquire_input_focus")
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function check_teleport(self, tile)
	if tile ~= tile_teleporter_green and tile ~= tile_teleporter_purple then
		return false
	end

	local lookup = self.teleporters.green
	if tile == tile_teleporter_purple then
		lookup = self.teleporters.purple
	end	

	local teleport_to = nil
	for index, coords in pairs(lookup) do
		if self.player_tile_position.x ~= coords.x or self.player_tile_position.y ~= coords.y then
			teleport_to = coords
			break
		end
	end

	if teleport_to ~= nil then
		self.teleporting = true
		sprite.play_flipbook(self.player_sprite_url, "portal_out", function()
			self.player_tile_position = {
				x = teleport_to.x,
				y = teleport_to.y
			}
			self.player_position.x = self.tilemap_position.x + (tile_size * self.player_tile_position.x - tile_size / 2)
			self.player_position.y = self.tilemap_position.y + (tile_size * self.player_tile_position.y - tile_size / 2)
			go.set(self.player_url, "position", self.player_position)

			sprite.play_flipbook(self.player_sprite_url, "portal_in", function()
				play_idle_animation(self)
				self.teleporting = nil
				self.movement = nil
			end)
		end)
	else
		return false
	end

	return true
end

local function check_solution(self)
	local solved = false
	if self.player_tile_position.x == self.exit_tile_position.x and self.player_tile_position.y == self.exit_tile_position.y then
		solved = true
	end

	if solved then
		if self.moves == self.required_moves then
			self.teleporting = true
			sprite.play_flipbook(self.player_sprite_url, "victory", function()
				self.teleporting = nil
				self.current_level = math.min(self.max_levels, self.current_level + 1)
				load_level(self)
			end)
		else
			play_lost_animation(self)
		end
	end

	if (not solved or not self.teleporting) and self.moves >= self.required_moves then
		play_lost_animation(self)
	end
end

local function play_collision_animation(self)
	if self.moves < self.required_moves then
		sound.play(msg.url(nil, "sound", "impact" .. math.random(1, 5)))
	end
	if self.movement.x == 1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_right", play_idle_animation)
	elseif self.movement.x == -1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_left", play_idle_animation)
	elseif self.movement.y == 1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_up", play_idle_animation)
	elseif self.movement.y == -1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_down", play_idle_animation)
	end
end

local function check_collision_wall(self, x, y)
	if self.tilemap_data[y][x] ~= tile_empty then
		return true
	end
	
	local item = self.tilemap_items[y][x]
	local walls = {
		[tile_oneway_up] = true,
		[tile_oneway_down] = true,
		[tile_oneway_left] = true,
		[tile_oneway_right] = true
	}

	if self.movement.x == 1 then
		walls[tile_oneway_right] = false
	elseif self.movement.x == -1 then
		walls[tile_oneway_left] = false
	elseif self.movement.y == 1 then
		walls[tile_oneway_up] = false
	elseif self.movement.y == -1 then
		walls[tile_oneway_down] = false
	end

	return walls[item] or false
end

local function check_bounds(self, player_position)
	local px = math.floor((player_position.x + (self.movement.x * tile_size / 2) - self.tilemap_position.x) / tile_size) + 1
	local py = math.floor((player_position.y + (self.movement.y * tile_size / 2) - self.tilemap_position.y) / tile_size) + 1

	if check_collision_wall(self, px, py) then
		self.player_tile_position.x = px - self.movement.x
		self.player_tile_position.y = py - self.movement.y
		if not check_teleport(self, self.tilemap_items[self.player_tile_position.y][self.player_tile_position.x]) then
			play_collision_animation(self)
		end
		player_position.x = self.tilemap_position.x + ((self.player_tile_position.x - 1) * tile_size) + tile_size / 2
		player_position.y = self.tilemap_position.y + ((self.player_tile_position.y - 1) * tile_size) + tile_size / 2
		self.moves = self.moves + 1
		self.movement = nil
		self.speed = 0
		msg.post(msg.url(nil, "gui", "level"), hash("update_moves"), { moves = self.moves })
		check_solution(self)
	end

	return player_position
end

function update(self, dt)
	if self.movement == nil then return end

	self.speed = self.speed + acceleration * dt
	self.speed = math.min(self.speed, max_movement_speed)
	
	local player_position = go.get(self.player_url, "position")
	player_position = player_position + (self.movement * self.speed)
	player_position = check_bounds(self, player_position)
	if player_position ~= nil then
		go.set(self.player_url, "position", player_position)
	end
end

function on_input(self, action_id, action)
	if self.movement ~= nil or self.teleporting ~= nil or self.resetting ~= nil then return end

	if action_id == hash("left") and action.pressed then
		self.movement = vmath.vector3(-1, 0, 0)
		if not check_collision_wall(self, self.player_tile_position.x - 1, self.player_tile_position.y) then
			sprite.play_flipbook(self.player_sprite_url, "move_left")
		else
			self.movement = nil
		end
	elseif action_id == hash("right") and action.pressed then
		self.movement = vmath.vector3(1, 0, 0)
		if not check_collision_wall(self, self.player_tile_position.x + 1, self.player_tile_position.y) then
			sprite.play_flipbook(self.player_sprite_url, "move_right")
		else
			self.movement = nil
		end
	elseif action_id == hash("up") and action.pressed then
		self.movement = vmath.vector3(0, 1, 0)
		if not check_collision_wall(self, self.player_tile_position.x, self.player_tile_position.y + 1) then
			sprite.play_flipbook(self.player_sprite_url, "move_up")
		else
			self.movement = nil
		end
	elseif action_id == hash("down") and action.pressed then
		self.movement = vmath.vector3(0, -1, 0)
		if not check_collision_wall(self, self.player_tile_position.x, self.player_tile_position.y - 1) then
			sprite.play_flipbook(self.player_sprite_url, "move_down")
		else
			self.movement = nil
		end
	elseif action_id == hash("key_r") and action.pressed then
		reset_level(self)
	elseif action_id == hash("back") and action.released then
		msg.post(msg.url("proxy", "/loader", "script"), "show_titlescreen")
	end
end
