go.property("current_level", 1)
go.property("max_levels", 4)

local width, height = window.get_size()
local tile_size = 16
local zoom = 4

local lume = require "libraries.lume"

local acceleration = 4
local max_movement_speed = 16

local tile_wall = 2
local tile_floor = 3
local tile_exit = 4
local tile_player_start = 5

local idle_animations = {
	[hash("idle")] = 4,
	[hash("idle_left")] = 4,
	[hash("idle_right")] = 4,
	[hash("idle_up")] = 4,
	[hash("idle_down")] = 4,
	[hash("blink")] = 2
}

local function play_idle_animation(self)
	local animation_to_play = lume.weightedchoice(idle_animations)
	sprite.play_flipbook(self.player_sprite_url, animation_to_play, play_idle_animation)
end

local function load_tilemap(self)
	local data = sys.load_resource("/game/levels/level" .. self.current_level .. ".lua")
	if data ~= nil then
		local level_data = assert(loadstring(data))()
		self.required_moves = level_data.properties.moves
		msg.post(msg.url(nil, "gui", "level"), hash("update_required"), { required = self.required_moves })
		for _, layer in ipairs(level_data.layers) do
			for y = 1, layer.height do
				for x = 1, layer.width do
					tilemap.set_tile(self.tilemap_level_url, layer.name, x, layer.height + 1 - y, layer.data[(y - 1) * layer.width + x])
				end
			end
		end
	else
		print("[ERROR] Level not found?")
	end
end

local function init_tilemap_position(self)
	tilemap.set_visible(self.tilemap_level_url, "items", false)

	self.tilemap_position = go.get(self.tilemap_url, "position")

	self.tilemap_x, self.tilemap_y, self.tilemap_width, self.tilemap_height = tilemap.get_bounds(self.tilemap_level_url)

	self.tilemap_position.x = (width / 2) - (self.tilemap_width * tile_size) / 2
	self.tilemap_position.y = height / 2 - (self.tilemap_height * tile_size) / 2

	go.set(self.tilemap_url, "position", self.tilemap_position)
end

local function init_tilemap_data(self)
	self.tilemap_data = tilemap.get_tiles(self.tilemap_level_url, "walls")
	self.exit_tile_position = { x = 0, y = 0 }
	self.player_start_tile_position = { x = 0, y = 0 }
	local items = tilemap.get_tiles(self.tilemap_level_url, "items")
	for row = 1, #items do
		for col = 1, #items[row] do
			if items[row][col] == tile_exit then
				self.exit_tile_position.x = col
				self.exit_tile_position.y = row
			elseif items[row][col] == tile_player_start then
				self.player_start_tile_position.x = col
				self.player_start_tile_position.y = row
			end
		end
	end
end

local function init_player_position(self)
	self.player_position = go.get(self.player_url, "position")
	self.player_position.x = self.tilemap_position.x + (tile_size * self.player_start_tile_position.x - tile_size / 2)
	self.player_position.y = self.tilemap_position.y + (tile_size * self.player_start_tile_position.y - tile_size / 2)
	self.player_tile_position = {
		x = self.player_start_tile_position.x,
		y = self.player_start_tile_position.y
	}
	go.set(self.player_url, "position", self.player_position)
end

local function init_exit_position(self)
	self.exit_position = go.get(self.exit_url, "position")
	self.exit_position.x = self.tilemap_position.x + (tile_size * self.exit_tile_position.x - tile_size / 2)
	self.exit_position.y = self.tilemap_position.y + (tile_size * self.exit_tile_position.y - tile_size / 2)
	go.set(self.exit_url, "position", self.exit_position)
end

local function load_level(self)
	self.speed = 0
	self.moves = 0
	self.required_moves = 0

	msg.post(msg.url(nil, "gui", "level"), hash("update_moves"), { moves = self.moves })

	load_tilemap(self)
	init_tilemap_position(self)
	init_tilemap_data(self)
	init_player_position(self)
	init_exit_position(self)

	play_idle_animation(self)
end

local function reset_level(self)
	self.moves = 0
	self.movement = nil
	msg.post(msg.url(nil, "gui", "level"), hash("update_moves"), { moves = self.moves })

	self.player_position.x = self.tilemap_position.x + (tile_size * self.player_start_tile_position.x - tile_size / 2)
	self.player_position.y = self.tilemap_position.y + (tile_size * self.player_start_tile_position.y - tile_size / 2)
	self.player_tile_position = {
		x = self.player_start_tile_position.x,
		y = self.player_start_tile_position.y
	}
	go.set(self.player_url, "position", self.player_position)

	play_idle_animation(self)
end

function init(self)
	msg.post("@render:", "use_fixed_projection", { near = -1, far = 1, zoom = zoom })

	sound.play(msg.url(nil, "sound", "music"))

	self.tilemap_url = msg.url(nil, "level", nil)
	self.tilemap_level_url = msg.url(nil, "level", "tilemap")
	self.exit_url = msg.url(nil, "exit", nil)
	self.player_url = msg.url(nil, "player", nil)
	self.player_sprite_url = msg.url(nil, "player", "sprite")
	self.player_size = go.get(self.player_sprite_url, "size")

	load_level(self)

	msg.post(".", "acquire_input_focus")
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function check_solution(self)
	print("Required moves: " .. self.required_moves)
	print("Moves taken: " .. self.moves)
	local solved = false
	local reset = false
	if self.player_tile_position.x == self.exit_tile_position.x and self.player_tile_position.y == self.exit_tile_position.y then
		solved = true
	end

	if solved then
		if self.moves == self.required_moves then
			sprite.play_flipbook(self.player_sprite_url, "portal", function()
				self.current_level = math.min(self.max_levels, self.current_level + 1)
				load_level(self)
				reset = true
			end)
		end
		print("Solved?: (true)")
	else
		print("Solved?: (false)")
	end

	if self.moves > self.required_moves then
		reset_level(self)
		reset = true
	end

	return reset
end

local function play_collision_animation(self)
	sound.play(msg.url(nil, "sound", "impact" .. math.random(1, 5)))
	if self.movement.x == 1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_right", play_idle_animation)
	elseif self.movement.x == -1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_left", play_idle_animation)
	elseif self.movement.y == 1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_up", play_idle_animation)
	elseif self.movement.y == -1 then
		sprite.play_flipbook(self.player_sprite_url, "collision_down", play_idle_animation)
	end
end

local function check_bounds(self, player_position)
	local px = math.floor((player_position.x + (self.movement.x * tile_size / 2) - self.tilemap_position.x) / tile_size) + 1
	local py = math.floor((player_position.y + (self.movement.y * tile_size / 2) - self.tilemap_position.y) / tile_size) + 1

	if self.tilemap_data[py][px] == tile_wall then
		play_collision_animation(self)
		self.player_tile_position.x = px - self.movement.x
		self.player_tile_position.y = py - self.movement.y
		player_position.x = self.tilemap_position.x + ((self.player_tile_position.x - 1) * tile_size) + tile_size / 2
		player_position.y = self.tilemap_position.y + ((self.player_tile_position.y - 1) * tile_size) + tile_size / 2
		self.moves = self.moves + 1
		self.movement = nil
		self.speed = 0
		msg.post(msg.url(nil, "gui", "level"), hash("update_moves"), { moves = self.moves })
		if check_solution(self) then
			player_position = nil
		end
	end
	
	return player_position
end

function update(self, dt)
	if self.movement == nil then return end

	self.speed = self.speed + acceleration * dt
	self.speed = math.min(self.speed, max_movement_speed)
	
	local player_position = go.get(self.player_url, "position")
	player_position = player_position + (self.movement * self.speed)
	player_position = check_bounds(self, player_position)
	if player_position ~= nil then
		go.set(self.player_url, "position", player_position)
	end
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if self.movement ~= nil then return end

	if action_id == hash("left") and action.pressed then
		self.movement = vmath.vector3(-1, 0, 0)
		sprite.play_flipbook(self.player_sprite_url, "move_left")
	elseif action_id == hash("right") and action.pressed then
		self.movement = vmath.vector3(1, 0, 0)
		sprite.play_flipbook(self.player_sprite_url, "move_right")
	elseif action_id == hash("up") and action.pressed then
		self.movement = vmath.vector3(0, 1, 0)
		sprite.play_flipbook(self.player_sprite_url, "move_up")
	elseif action_id == hash("down") and action.pressed then
		self.movement = vmath.vector3(0, -1, 0)
		sprite.play_flipbook(self.player_sprite_url, "move_down")
	end
end
