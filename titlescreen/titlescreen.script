local sprite_size = 8
local max_tile_x = 12
local max_tile_y = 12
local tile_empty = 0

local load_level

local function reset_tilemap_layer(self, layer)
	for y = 1, max_tile_y do
		for x = 1, max_tile_x do
			tilemap.set_tile(self.tilemap_level_url, layer, x, y, tile_empty)
		end
	end
end

local function gui_to_world(gui_pos, screen_width, screen_height)
	-- Convert GUI pixel position to normalized device coordinates (-1 to 1)
	local nx = (gui_pos.x / screen_width) * 2 - 1
	local ny = (gui_pos.y / screen_height) * 2 - 1

	-- Point in camera space (z=0, w=1)
	local camera_space_point = vmath.vector4(nx, ny, 0, 1)

	local view = camera.get_view("/camera#camera")
	local proj = camera.get_projection("/camera#camera")

	-- Invert the camera view matrix
	local inv_view = vmath.inv(proj * view)

	-- Transform from camera space to world space
	local world_space_point = inv_view * camera_space_point

	-- Return vector3 world position
	return vmath.vector3(world_space_point.x, world_space_point.y, world_space_point.z)
end

local function position_level(self)
	if self.tilemap_width == nil then return end

	local current_width, current_height = window.get_size()
	local pos = self.preview_position or vmath.vector3()
	local world_pos = gui_to_world(pos, current_width, current_height)

	-- Offset for your tilemap
	local w = sprite_size * self.tilemap_width
	local h = sprite_size * self.tilemap_height
	world_pos.x = world_pos.x - w / 2
	world_pos.y = world_pos.y - h / 2

	go.set_position(world_pos, self.tilemap_id)
end

local function load_tilemap(self, level)
	local data = sys.load_resource("/game/levels/level" .. level .. ".lua")
	if data ~= nil then
		self.tilemap_width = 0
		self.tilemap_height = 0
		local level_data = assert(loadstring(data))()
		for _, layer in ipairs(level_data.layers) do
			reset_tilemap_layer(self, layer.name)
			for y = 1, layer.height do
				for x = 1, layer.width do
					tilemap.set_tile(self.tilemap_level_url, layer.name, x, layer.height + 1 - y, layer.data[(y - 1) * layer.width + x])
				end
			end
			self.tilemap_width = math.max(self.tilemap_width, layer.width)
			self.tilemap_height = math.max(self.tilemap_height, layer.height)
		end
		position_level(self)
	end
end

load_level = function(self, level)
	self.tilemap_id = factory.create(msg.url(nil, "levelselect", "level"), vmath.vector3(self.width / 2, self.height / 2, 0.1))
	self.tilemap_level_url = msg.url(nil, self.tilemap_id, "tilemap")
end

local function animate_background()
	local size = go.get_scale("/scroll")
	local scale = vmath.vector4(size.x / sprite_size, size.y / sprite_size, 0, 0)
	go.set("/scroll#plane", "scale", scale)
	go.set("/scroll#plane", "tint.w", 0.5)
	go.animate("/scroll#plane", "animation_time.x", go.PLAYBACK_LOOP_FORWARD, scale.xy, go.EASING_LINEAR, 120 * scale.xy)
end

function init(self)
	msg.post("/camera#camera", "enable")
	msg.post("@render:", "use_camera_projection")

	self.width = sys.get_config_int("display.width")
	self.height = sys.get_config_int("display.height")

	animate_background()
end

function on_message(self, message_id, message)
	if message_id == hash("show_tilemap") then
		load_level(self, message.level or 1)
	elseif message_id == hash("preview_level") and self.tilemap_id then
		self.preview_position = message.preview_position
		load_tilemap(self, message.level)
	elseif message_id == hash("hide_tilemap") then
		if self.tilemap_id and go.exists(self.tilemap_id) then
			go.delete(self.tilemap_id, true)
		end
	end
end

function on_input(self, action_id, action)
	if action.released then
		msg.post(msg.url("proxy", "/loader", "script"), "show_level")
	end
end
