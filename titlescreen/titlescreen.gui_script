local defsave = require "defsave.defsave"
local table = table
local srep = string.rep

local function lpad(s, l, c)
	return srep(c or ' ', l - #tostring(s)) .. s
end

local function update_cursor(self)
	self.active_item = self.menu_items[self.active_index]

	local position = gui.get_position(self.active_item)
	local cursor = gui.get_position(self.select_node)
	cursor.y = position.y + self.select_scale.y * 2
	gui.set_position(self.select_node, cursor)
	gui.play_flipbook(self.select_node, "blink", function()
		gui.play_flipbook(self.select_node, "idle")
	end)
end

function init(self)
	self.current_level = defsave.get("settings", "level") or 1
	self.max_levels = defsave.get("settings", "max_level") or 1
	self.level_selected = self.max_levels

	self.select_node = gui.get_node("select")
	self.select_scale = gui.get_scale(self.select_node)
	
	self.continue_node = gui.get_node("menu_item_continue/title")
	self.new_game_node = gui.get_node("menu_item_newgame/title")
	self.levelselect_node = gui.get_node("menu_item_levelselect/title")
	self.levelselect_text = gui.get_text(self.levelselect_node)
	self.credits_node = gui.get_node("menu_item_credits/title")

	self.proxy_url = msg.url("proxy", "/loader", "script")

	self.menu_items = {}

	if self.current_level > 1 then
		table.insert(self.menu_items, self.continue_node)
	else
		gui.set_visible(self.continue_node, false)
	end

	table.insert(self.menu_items, self.new_game_node)
	table.insert(self.menu_items, self.levelselect_node)
	table.insert(self.menu_items, self.credits_node)

	self.active_index = 1
	update_cursor(self)
	gui.set_text(self.levelselect_node, self.levelselect_text .. lpad(self.level_selected, 2, '0'))

	msg.post(".", "acquire_input_focus")
end

function final(self)
	msg.post(".", "release_input_focus")
end

function on_input(self, action_id, action)
	if not action.released then return end
	
	if action_id == hash("touch") then
		if self.active_item == self.continue_node then
			msg.post(self.proxy_url, "show_level", { current_level = self.current_level } )
		elseif self.active_item == self.levelselect_node then
			msg.post(self.proxy_url, "show_level", { current_level = self.level_selected } )
		elseif self.active_item == self.new_game_node then
			msg.post(self.proxy_url, "show_level")
		end
	elseif action_id == hash("up") then
		self.active_index = math.max(1, self.active_index - 1)
		update_cursor(self)
	elseif action_id == hash("down") then
		self.active_index = math.min(4, self.active_index + 1)
		update_cursor(self)
	elseif action_id == hash("left") and self.active_item == self.levelselect_node then
		self.level_selected = math.max(1, self.level_selected - 1)
		gui.set_text(self.levelselect_node, self.levelselect_text .. lpad(self.level_selected, 2, '0'))
	elseif action_id == hash("right") and self.active_item == self.levelselect_node then
		self.level_selected = math.min(self.max_levels, self.level_selected + 1)
		gui.set_text(self.levelselect_node, self.levelselect_text .. lpad(self.level_selected, 2, '0'))
	end
end
